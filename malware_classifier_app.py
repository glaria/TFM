import streamlit as st
from functions.feature_extraction import *
import pandas as pd
import tempfile
import os
from functions.ml_model import *
import base64

st.title('Clasificador de Malware')

st.write("""
Clasificador binario basado en el modelo descrito en la memoria del TFM
""")

def download_csv_link(df, filename, message="Descargar el csv con las etiquetas"):
    csv = df.to_csv(index=False)
    b64 = base64.b64encode(csv.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="{filename}">{message}</a>'
    return href

# widgets de carga de archivos en el sidebar
st.sidebar.title('Carga de archivos ejecutables o ficheros csv con características')

file = st.sidebar.file_uploader("Selecciona un archivo ejecutable o un CSV", type=["exe", "csv"], accept_multiple_files=False)

#lista de caracteristicas usadas por el modelo
feature_cols = ['MinorOperatingSystemVersion', 'BaseOfCode', 'SizeOfOptionalHeader',
                'SizeOfHeapCommit', 'CheckSum', 'MinorImageVersion',
                'MinorLinkerVersion', 'MajorSubsystemVersion', 'NumberOfRvaAndSizes',
                'MajorLinkerVersion', 'SizeOfUninitializedData',
                'MinorSubsystemVersion', 'SizeOfStackReserve',
                'MajorOperatingSystemVersion', 'SizeOfHeapReserve', 'SizeOfCode',
                'AddressOfEntryPoint', 'LoaderFlags', 'ImageBase',
                'SizeOfInitializedData', 'MajorImageVersion', 'SectionAlignment',
                'SizeOfHeaders', 'Subsystem', 'Characteristics', 'Machine',
                'SizeOfImage', 'FileAlignment', 'DllCharacteristics']

csv_file = None
exe_file = None
if file is not None:
    file_extension = os.path.splitext(file.name)[1].lower()
    if file_extension == ".csv":
        csv_file = file
        csv_sep = st.sidebar.text_input("Introduce el separador del CSV (si no es una coma)", value=",")
        exe_file = None
    else:
        exe_file = file

#mostramos las primeras 4 filas con las características
if csv_file is not None:
    # carga y visualizacion de las primeras filas del archivo CSV
    try:
        csv_df = pd.read_csv(csv_file, sep=csv_sep)
        preview_df = csv_df.head(4)
        st.write("Vista previa del archivo CSV cargado:")
        st.dataframe(preview_df)

    except Exception as e:
        st.write("Error al cargar el archivo CSV. Por favor, revisa el separador CSV del archivo:", e)

if exe_file is not None:
    try:
        # nombre del archivo, streamlite cambia el nombre del archivo, por lo que debemos pasar el valor original como parámetro
        exe_file_name = exe_file.name
        # se guarda el archivo cargado en una ubicación temporal
        with tempfile.NamedTemporaryFile(delete=False) as fp:
            fp.write(exe_file.getvalue())
            temp_path = fp.name
            
        #extraemos las características del archivo ejecutable
        features = extract_features(temp_path, exe_file_name)

        st.write("Se extrajeron las características del archivo ejecutable con éxito.")
        st.write("Las características extraídas son:")
        st.table(pd.DataFrame([features]))
        # ya se puede borrar el archivo temporal
        os.unlink(temp_path)
    except Exception as e:
        st.write("Ocurrió un error al cargar el archivo ejecutable:", e)
    finally:
        #ya se puede borrar el archivo temporal
        if os.path.exists(temp_path):
            os.unlink(temp_path)


if st.button("Clasificar"):
    if csv_file is not None:
        # Procesamiento del archivo CSV
        try:

            # mapeo de nombres de columna en minúsculas a sus versiones originales
            column_mapping = {col.lower(): col for col in feature_cols}

            # lista de nombres de columnas en minúsculas para la comparación
            lower_feature_cols = [col.lower() for col in feature_cols]

            # se identifican las características que están presentes en el CSV
            available_features = [col for col in csv_df.columns if col.lower() in lower_feature_cols]

            # Creamos una copia del DataFrame original para evitar cambiarlo
            df = csv_df.copy()

            # Se cambian los nombres de las columnas al formato original
            df.columns = [column_mapping[col.lower()] if col.lower() in column_mapping else col for col in df.columns]

            # solo las columnas disponibles
            processed_df = df[available_features]
            # miramos si faltan columnas
            missing_features = set(feature_cols) - set(available_features)
            if missing_features:
                st.write("Advertencia: Faltan características del modelo, sus valores se inicializarán a cero, por lo que los resultados tendrán menos exactitud")
                st.write("Características no disponibles:", list(missing_features))
                # Para cada característica faltante, añade una columna con valor 0
                for feature in missing_features:
                    df[feature] = 0
    
                # Ahora, processed_df tiene todas las columnas necesarias
                processed_df = df[feature_cols]
    
            st.write("Se procesó el archivo CSV con éxito.")
            # A continuación, podemos proceder con la clasificación de los datos en df.
            #llamadaa la función evaluate_model del archivo ml_model.py
            output_df = evaluate_model(processed_df, 'csv')
            
            # Añadir la columna 'Malware_Flag' al DataFrame original
            csv_df['Malware_Flag'] = output_df['Malware_Flag']
            
            # Mostrar el DataFrame
            st.write(csv_df)

            # link para descargar el df como csv
            st.markdown(download_csv_link(csv_df, "results.csv"), unsafe_allow_html=True)

        except Exception as e:
            st.write("Ocurrió un error al cargar el archivo CSV:", e)
    elif exe_file is not None: #estamos ante un ejecutable
        st.write("Clasificación del ejecutable")
        selected_features  = select_features(features, feature_cols)

        #lo convertimos a dataframe de pandas
        df = pd.DataFrame([selected_features])
        output_model = evaluate_model(df, 'exe')
        if output_model ==0:
            output_value = ':green[Archivo Benigno]'
        else:
            output_value = ':red[Archivo Malicioso]'
        st.markdown(output_value)
    else:
        st.write("Por favor, carga un archivo antes de intentar clasificar.")